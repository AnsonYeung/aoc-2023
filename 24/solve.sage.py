

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_200000000000000 = Integer(200000000000000); _sage_const_400000000000000 = Integer(400000000000000); _sage_const_300 = Integer(300); _sage_const_2 = Integer(2)#!/usr/bin/env python3
from sys import stdin, exit
from copy import *
from heapq import *
from collections import *
from itertools import *
from functools import *
from math import *
from tqdm import tqdm
import re
import numpy as np
import os
import sys
from sage import *
from base64 import b64encode
from typing import Any, Callable, TypeVar
T = TypeVar("T")

def copy_to_clipboard(s: str):
    # Copy to clipboard using OSC52
    print(f"\x1b]52;c;{b64encode(s.encode()).decode()}\x07", end="")

def ints(l: list[str]) -> list[int]:
    return [int(s) for s in l]

def str_to_ints(s: str) -> list[int]:
    return ints(re.findall(r"-?\d+", s))

def make_matrix(r: int, c: int, default: Callable[[], T]) -> list[list[T]]:
    return [[default() for _ in range(c)] for _ in range(r)]

def print_matrix(data: list[list[Any]]):
    for r in data:
        for x in r:
            print(x, end="")
        print()
    print()

if stdin.isatty():
    with open("input.txt", "r") as f:
        data = f.read().split('\n')[:-_sage_const_1 ]
else:
    data = stdin.read().split('\n')[:-_sage_const_1 ]

parsed = []
for line in data:
    parsed.append(str_to_ints(line))

def intersect_xy(l1, l2) -> bool:
    x1, y1, _, vx1, vy1, _ = l1
    x2, y2, _, vx2, vy2, _ = l2
    # x1 + t1 vx1 = x2 + t2 vx2
    # y1 + t1 vy1 = y2 + t2 vy2

    # t1 vx1 - t2 vx2 = x2 - x1
    # t1 vy1 - t2 vy2 = y2 - y1
    # vx1 -vx2
    # vy1 -vy2
    determinant = -vy2 * vx1 + vx2 * vy1
    if determinant == _sage_const_0 :
        # parallel
        c1 = (y2 - y1) / (x2 - x1)
        c2 = vy2 / vx2
        c3 = vy1 / vx1
        print("parallel", c1, c2, c3)
        return c1 == c2
    else:
        # solve for t1 and t2
        # inv / det:
        # -vy2 vx2
        # -vy1 vx1
        t1 = (x2 - x1) / determinant * -vy2 + (y2 - y1) / determinant * vx2
        t2 = (x2 - x1) / determinant * -vy1 + (y2 - y1) / determinant * vx1
        print("not parallel", t1, t2)
        if t1 >= _sage_const_0  and t2 >= _sage_const_0 :
            ix = x1 + t1 * vx1
            iy = y1 + t1 * vy1
            if _sage_const_200000000000000  <= ix <= _sage_const_400000000000000  and _sage_const_200000000000000  <= iy <= _sage_const_400000000000000 :
                return True
        return False

def part1():
    ans = _sage_const_0 
    for i in range(len(parsed)):
        for j in range(i + _sage_const_1 , len(parsed)):
            if intersect_xy(parsed[i], parsed[j]):
                ans += _sage_const_1 
    print(f"Part 1: {ans}")
    copy_to_clipboard(str(ans))

def part2():
    ans = 0
    # simply a big linear system of equations
    # variables: x, y, z, vx, vy, vz, t1, ..., t300
    # 300 * 3 = 900 equations
    # only need 306, so just first 102 pts
    x, y, z, vx, vy, vz = var("x y z vx vy vz")
    t = [var(f"t{i}") for i in range(_sage_const_300 )]
    equations = []
    rhs = []
    for i in range(_sage_const_300 ):
        x1, y1, z1, vx1, vy1, vz1 = parsed[i]
        # x + t1 vx = x1 + t1 vx1
        # x + t1 vx = x1 + t1 vx1
        equations.append(x + t[i] * vx == x1 + t[i] * vx1)
        equations.append(y + t[i] * vy == y1 + t[i] * vy1)
        equations.append(z + t[i] * vz == z1 + t[i] * vz1)
    print(equations)
    result = solve(equations, [x, y, z, vx, vy, vz, *t])
    print(result)
    ans = result[_sage_const_0 ][_sage_const_0 ] + result[_sage_const_0 ][_sage_const_1 ] + result[_sage_const_0 ][_sage_const_2 ]
    print(f"Part 2: {ans}")
    copy_to_clipboard(str(ans))

if __name__ == "__main__":
    part1()
    part2()

